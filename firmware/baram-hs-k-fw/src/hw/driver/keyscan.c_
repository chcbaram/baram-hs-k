#include "keyscan.h"


#ifdef _USE_HW_KEYSCAN
#include "cli.h"


#define KEYSCAN_DMA_MAX_NODE        10


typedef struct
{
  uint16_t         node_cnt;
  DMA_NodeTypeDef  node[KEYSCAN_DMA_MAX_NODE];
  DMA_QListTypeDef list;
} keyscan_dma_t;

#if CLI_USE(HW_KEYSCAN)
static void cliCmd(cli_args_t *args);
#endif
static bool keyscanInitDMA(void);
static bool keyscanInitTIM(void);
static void keyscanTransferCompleteDMA(DMA_HandleTypeDef *hdma);
static void keyscanTransferErrorDMA(DMA_HandleTypeDef *hdma);


static keyscan_dma_t keyscan_dma;

static uint32_t keyscan_buf[1024];
static DMA_HandleTypeDef h_dma;
static TIM_HandleTypeDef htim17;




bool keyscanInit(void)
{

  keyscanInitTIM();
  keyscanInitDMA();

#if CLI_USE(HW_KEYSCAN)
  cliAdd("keyscan", cliCmd);
#endif

  return true;
}

bool keyscanInitTIM(void)
{
  // 80Khz
  //
  htim17.Instance               = TIM17;
  htim17.Init.Prescaler         = 19;
  htim17.Init.CounterMode       = TIM_COUNTERMODE_UP;
  htim17.Init.Period            = 99;
  htim17.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;
  htim17.Init.RepetitionCounter = 0;
  htim17.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim17) != HAL_OK)
  {
    Error_Handler();
  }
  HAL_TIM_Base_Stop(&htim17);

  return true;
}

bool keyscanInitDMA(void)
{
  bool ret = true;
  DMA_NodeConfTypeDef node_cfg;
  HAL_StatusTypeDef hal_ret = HAL_OK;

  uint32_t gpio_port_tbl[] = {
    GPIOA->IDR,
    GPIOB->IDR,
    GPIOC->IDR,
    GPIOD->IDR,
    GPIOE->IDR,
    GPIOF->IDR,
    GPIOG->IDR,
    GPIOH->IDR,
    GPIOI->IDR,
    GPIOJ->IDR,
  };


  node_cfg.NodeType                            = DMA_GPDMA_LINEAR_NODE;
  node_cfg.Init.Request                        = GPDMA1_REQUEST_TIM17_UP;
  node_cfg.Init.BlkHWRequest                   = DMA_BREQ_SINGLE_BURST;
  node_cfg.Init.Direction                      = DMA_MEMORY_TO_MEMORY;
  node_cfg.Init.SrcInc                         = DMA_SINC_FIXED;
  node_cfg.Init.DestInc                        = DMA_DINC_INCREMENTED;
  node_cfg.Init.SrcDataWidth                   = DMA_SRC_DATAWIDTH_WORD;
  node_cfg.Init.DestDataWidth                  = DMA_DEST_DATAWIDTH_WORD;
  node_cfg.Init.SrcBurstLength                 = 1;
  node_cfg.Init.DestBurstLength                = 1;
  node_cfg.Init.TransferAllocatedPort          = DMA_SRC_ALLOCATED_PORT0 | DMA_DEST_ALLOCATED_PORT1;
  node_cfg.Init.TransferEventMode              = DMA_TCEM_BLOCK_TRANSFER;

  node_cfg.RepeatBlockConfig.RepeatCount       = 1;
  node_cfg.RepeatBlockConfig.SrcAddrOffset     = 0;
  node_cfg.RepeatBlockConfig.DestAddrOffset    = 0;
  node_cfg.RepeatBlockConfig.BlkSrcAddrOffset  = 0;
  node_cfg.RepeatBlockConfig.BlkDestAddrOffset = 0;
  
  node_cfg.TriggerConfig.TriggerPolarity       = DMA_TRIG_POLARITY_MASKED;
  // node_cfg.TriggerConfig.TriggerMode           = DMA_TRIGM_SINGLE_BURST_TRANSFER;
  // node_cfg.TriggerConfig.TriggerPolarity       = DMA_TRIG_POLARITY_MASKED;
  // node_cfg.TriggerConfig.TriggerSelection      = GPDMA1_TRIGGER_TIM15_TRGO;
  
  node_cfg.DataHandlingConfig.DataExchange     = DMA_EXCHANGE_NONE;
  node_cfg.DataHandlingConfig.DataAlignment    = DMA_DATA_RIGHTALIGN_ZEROPADDED;
  
  node_cfg.SrcAddress                          = (uint32_t)&GPIOC->IDR;
  // node_cfg.SrcAddress                          = (uint32_t)keyscan_buf;
  node_cfg.DstAddress                          = (uint32_t)keyscan_buf;
  node_cfg.DataSize                            = 1024*4U;

  hal_ret |= HAL_DMAEx_List_BuildNode(&node_cfg, &keyscan_dma.node[0]);
  hal_ret |= HAL_DMAEx_List_InsertNode_Tail(&keyscan_dma.list, &keyscan_dma.node[0]);

  // hal_ret |= HAL_DMAEx_List_SetCircularMode(&keyscan_dma.list);



  __HAL_RCC_GPDMA1_CLK_ENABLE();

  h_dma.Instance                         = GPDMA1_Channel13;
  h_dma.InitLinkedList.Priority          = DMA_HIGH_PRIORITY;
  h_dma.InitLinkedList.LinkStepMode      = DMA_LSM_FULL_EXECUTION;
  h_dma.InitLinkedList.LinkAllocatedPort = DMA_LINK_ALLOCATED_PORT1;
  h_dma.InitLinkedList.TransferEventMode = DMA_TCEM_BLOCK_TRANSFER;
  h_dma.InitLinkedList.LinkedListMode    = DMA_LINKEDLIST_NORMAL;
  if (HAL_DMAEx_List_Init(&h_dma) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_DMA_ConfigChannelAttributes(&h_dma, DMA_CHANNEL_NPRIV) != HAL_OK)
  {
    Error_Handler();
  }

  /* Link queue to DMA channel */
  if (HAL_DMAEx_List_LinkQ(&h_dma, &keyscan_dma.list) != HAL_OK)
  {
    Error_Handler();
  }

  // __HAL_LINKDMA(&htim17, hdma[TIM_DMA_ID_UPDATE], h_dma);


  HAL_DMA_RegisterCallback(&h_dma, HAL_DMA_XFER_CPLT_CB_ID, keyscanTransferCompleteDMA);
  HAL_DMA_RegisterCallback(&h_dma, HAL_DMA_XFER_ERROR_CB_ID, keyscanTransferErrorDMA);

  // if (HAL_DMAEx_List_Start_IT(&h_dma) != HAL_OK)
  // {
  //   Error_Handler();
  // }

  HAL_NVIC_SetPriority(GPDMA1_Channel13_IRQn, 7, 0);
  HAL_NVIC_EnableIRQ(GPDMA1_Channel13_IRQn);

  return ret;
}

static volatile uint32_t dma_cnt = 0;
static volatile uint32_t dma_pre_time = 0;
static volatile uint32_t dma_exe_time = 0;

void keyscanTransferCompleteDMA(DMA_HandleTypeDef *hdma)
{
  dma_cnt++;
  dma_exe_time = micros()-dma_pre_time;
  return;
}

void keyscanTransferErrorDMA(DMA_HandleTypeDef *hdma)
{
  logPrintf("dma error\n");
}

void GPDMA1_Channel13_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&h_dma);
}

#if CLI_USE(HW_KEYSCAN)
void cliCmd(cli_args_t *args)
{
  bool ret = false;



  if (args->argc == 1 && args->isStr(0, "info"))
  {
    ret = true;
  }

  if (args->argc == 1 && args->isStr(0, "test"))
  {
    dma_pre_time = micros();
    if (HAL_DMAEx_List_Start_IT(&h_dma) != HAL_OK)
    {
      Error_Handler();
    }
    dma_cnt = 0;
    cliPrintf("%d\n", h_dma.Instance->CBR1);
    delay(500);
    cliPrintf("%d\n", h_dma.Instance->CBR1);
    delay(500);
    cliPrintf("%d\n", h_dma.Instance->CBR1);
    cliPrintf("dma cnt %d \n", dma_cnt);
    cliPrintf("dma exe %d \n", dma_exe_time);
    HAL_DMA_Abort(&h_dma);

    ret = true;
  }

  if (ret == false)
  {
    cliPrintf("keyscan info\n");
    cliPrintf("keyscan test\n");
  }
}
#endif

#endif